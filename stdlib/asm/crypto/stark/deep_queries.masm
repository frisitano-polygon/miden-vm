
#<= [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,       Z]
#=> [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,       Z]
export.deep_query_aux_1

    # Get T_i(z), T_i(gz)
    swapw
    dup.6
    mem_loadw
    push.0.0
    dup.8 
    add.41
    mem_loadw
    drop drop
    #=> [T_i(gz)1, T_i(gz)0, T_i(z)1, T_i(z)0, value_{i}1, value_{i}0, p1, p2, Y, Acc,      Z ]

    # Compute the numerators
    swapw
    dup.1
    dup.1
    movup.9
    movup.9
    ext2sub
    #=> [value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0, value_{i}1, value_{i}0, p1, p2, T_i(gz)1, T_i(gz)0, Y, Acc,      Z ]

    movdn.7
    movdn.7
    dup.1
    dup.1
    movup.7
    movup.7
    ext2sub
    movdn.5
    movdn.5
    #=> [value_{i}1, value_{i}0, p1, p2, value_{i}1 - T_i(gz)1, value_{i}0 - T_i(gz)0, value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0, Y, Acc,      Z ]
    #=> [value_{i}1, value_{i}0, p1, p2, T, Y, Acc,      Z ] 
    # where T := [value_{i}1 - T_i(gz)1, value_{i}0 - T_i(gz)0, value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0]

    # Multiply by randomness
    ## Get [alpha1, alpha0, beta1, beta0]
    movupw.2
    dup.7
    add.1
    swap.8
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_{i}1, value_{i}0, p1, p2, T, Acc,      Z ]
    swap
    swap.3
    swap
    swap.2
    #=> [[beta1, beta0, alpha1, alpha0], value_{i}1, value_{i}0, p1, p2, T, Acc,      Z]
    swapdw
    movupw.2
    #=> [[beta1, beta0, alpha1, alpha0], T, Acc, value_{i}1, value_{i}0, p1, p2,     Z]

    ## Multiply the shifted term
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, T, Acc, value_{i}1, value_{i}0, p1, p2,      Z]
    # Where (prod0_g, prod1_g) =  (T0, T1) * alpha 

    ## Multiply the non-shifted term
    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_{i}1, value_{i}0, p1, p2,      Z]
    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_i, p1, p2, p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta

    ## Shuffle stack to prepare for accumulating
    movup.7
    movup.7  
    #=> [prod1_g, prod0_g, prod1, prod0, ..]
    swap
    swap.3
    swap
    swap.2
    #=> [prod1, prod0, prod1_g, prod0_g, ..]
    dupw.2
    #=> [Acc, prod1_g, prod0_g, prod1, prod0, Y, Acc, value_{i}1, value_{i}0, p2, p3,      Z]

    # Accumulate
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [Acc3+prod1, Acc2+prod0, Acc1+prod1_g, Acc0+prod0_g, Y, Acc, value_{i}1, value_{i}0, p2, p3,      Z]           Acc = [Tz, Tz, Tgz, Tgz]
    #=> [Acc, Y, Y, P,      Z]
    swapw.3
    #=> [P, Y, Y, Acc,       Z]
end

#<= [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,       Z]
#=> [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,       Z]
export.deep_query_aux_2

    # Get T_i(z), T_i(gz)
    swapw
    dup.6
    add.1
    swap.7
    mem_loadw
    movup.3
    movup.3
    push.0.0
    dup.8 
    add.40          #   40 instead of 41 because we added 1 a few lines above
    mem_loadw
    movup.2 drop
    movup.2 drop
    #=> [T_i(gz)1, T_i(gz)0, T_i(z)1, T_i(z)0, value_{i}1, value_{i}0, p1, p2, Y, Acc,      Z ]

    # Compute the numerators
    swapw
    dup.1
    dup.1
    movup.9
    movup.9
    ext2sub
    #=> [value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0, value_{i}1, value_{i}0, p1, p2, T_i(gz)1, T_i(gz)0, Y, Acc,      Z ]
    movdn.7
    movdn.7
    dup.1
    dup.1
    movup.7
    movup.7
    ext2sub
    movdn.5
    movdn.5
    #=> [value_{i}1, value_{i}0, p1, p2, value_{i}1 - T_i(gz)1, value_{i}0 - T_i(gz)0, value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0, Y, Acc,      Z ]
    #=> [value_{i}1, value_{i}0, p1, p2, T, Y, Acc,      Z ] 
    # where T := [value_{i}1 - T_i(gz)1, value_{i}0 - T_i(gz)0, value_{i}1 - T_i(z)1, value_{i}0 - T_i(z)0]

    # Multiply by randomness
    ## Get [alpha1, alpha0, beta1, beta0]
    movupw.2
    #=> [Y, value_{i}1, value_{i}0, p1, p2, T, Acc,      Z ]
    dup.7
    add.1
    swap.8
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_{i}1, value_{i}0, p1, p2, T, Acc,      Z]
    swapdw
    movupw.2
    #=> [[alpha1, alpha0, beta1, beta0], T, Acc, value_{i}1, value_{i}0, p1, p2,     Z]

    ## Shuffle the random coefficients
    ## TODO: remove need for this
    swap
    swap.3
    swap
    swap.2
    #=> [[beta1, beta0, alpha1, alpha0], T, Acc, value_{i}1, value_{i}0, p1, p2,     Z]
  
    ## Multiply the shifted term
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, T, Acc, value_{i}1, value_{i}0, p1, p2,      Z]
    # Where (prod0_g, prod1_g) =  (T0, T1) * alpha 

    ## Multiply the non-shifted term
    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_{i}1, value_{i}0, p1, p2,      Z]
    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_i, p1,p2, p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta

    # Permute the two products in order to align with the accumulator
    movup.7
    movup.7
    #=> [prod1_g, prod0_g, prod1, prod0, ..]
    swap
    swap.3
    swap
    swap.2
    #=> [prod1, prod0, prod1_g, prod0_g, ..]
    dupw.2
    #=> [Acc, prod1_g, prod0_g, prod1, prod0, y, y, y, y, Acc, value_i, p1,p2, p3,      Z]

    # Accumulate
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [Acc3 + prod1, Acc2 + prod0, Acc1 + prod1_g, Acc0 + prod0_g, y, y, y, y, Acc, value_i, p1,p2, p3,      Z]
    #=> [Acc, Y, Y, P,      Z]
    # where Acc = [Tz, Tz, Tgz, Tgz]

    # Shuffle stack in case of further iterations
    swapw.3
    #=> [P, Y, Y, Acc,       Z]
end


#=> [Y, P, Y, Acc,      Z]
#<= [Y, P, Y, Acc,      Z]
export.deep_query_1

    # Get value_i := T_i(x)
    dup.7
    mem_loadw
    movup.4
    #=> [Y, value_i, p1, p2, p3, Y, Acc,      Z ]

    # Get T_i(z), T_i(gz)
    dup.5
    mem_loadw
    push.0.0
    dup.7 add.41
    mem_loadw
    drop drop
    neg 
    swap.2
    neg
    #=> [ - T_i(z)_1, T_i(gz)_0, - T_i(gz)_1, T_i(z)_0, value_i, p1, p2, p3, Y, Acc,      Z ]

    # Compute numerator
    swapw
    dup
    movup.6
    sub
    #=> [value_i - T_i(gz)_0, value_i, p1,p2,p3, - T_i(z)_1, - T_i(gz)_1, T_i(z)_0,, Y, Acc,      Z ]
    movdn.7
    swapw
    dup.4
    movup.3
    sub
    swap
    swapw.2
    #=> [Y, value_i, p1,p2,p3, T, Acc,      Z]      where T := [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0]

    # Multiply by randomness
    ## Get [alpha1, alpha0, beta1, beta0]
    dup.6
    add.1
    swap.7
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_i, p1,p2,p3, T, Acc,      Z]
    swapdw
    movupw.2
    #=> [[alpha1, alpha0, beta1, beta0], T, Acc, value_i, p1,p2,p3,      Z]

    ## Multiply the shifted term
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, - T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_Acc, 0, value_i, p1,p2,p3,      Z]
    # Where (prod0_g, prod1_g) =  (value_i - T_i(gz)_0, - T_i(gz)_1) * alpha = (T_i(x) - T_i(gz)) * alpha

    ## Multiply the non-shifted term
    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_i, p1,p2,p3,      Z]
    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_i, p1,p2,p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta
    movup.7
    movup.7
    dupw.2
    #=> [Acc, prod1_g, prod0_g, prod1, prod0, y, y, y, y, Acc, value_i, p1,p2,p3,      Z]

    # Accumulate
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [Acc3 + prod1, Acc2 + prod0, Acc1 + prod1_g, Acc0 + prod0_g, y, y, y, y, Acc, value_i, p1,p2,p3,      Z]           Acc = [Tz, Tz, Tgz, Tgz]
    #=> [Acc, Y, Y, P,      Z]

    # Prepare for next iteration, if any
    swapw.3
    swapw
    #=> [Y, P, Y, Acc,      Z]
end


#=> [Y, P, Y, Acc,      Z]
export.deep_query_2

    # Get value_i := T_i(x)
    dup.7
    mem_loadw
    swap.2
    swap.4
    #=> [Y, value_i, p1,p2,p3, Y, Acc,      Z ]

    # Get T_i(z), T_i(gz)
    dup.5
    mem_loadw
    movup.3
    movup.3
    push.0.0
    dup.7 add.41
    mem_loadw
    movup.3
    movup.3
    drop drop
    neg 
    swap.2
    neg
    #=> [ - T_i(z)_1, T_i(gz)_0, - T_i(gz)_1, T_i(z)_0, value_i, p1, p2, p3, Y, Acc,      Z ]

    # Update p1
    movup.5
    add.1
    movdn.5


    # Compute numerator
    swapw
    dup
    movup.6
    sub
    #=> [value_i - T_i(gz)_0, value_i, p1,p2,p3, - T_i(z)_1, - T_i(gz)_1, T_i(z)_0,, Y, Acc,      Z ]
    movdn.7
    swapw
    dup.4
    movup.3
    sub
    swap
    swapw.2
    #=> [Y, value_i, p1,p2,p3, T, Acc,      Z]      where T := [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0]

    # Multiply by random coefficients
    ## Get [alpha1, alpha0, beta1, beta0]
    dup.6
    add.1
    swap.7
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_i, p1,p2,p3, T, Acc,      Z]
    swapdw
    movupw.2
    #=> [[alpha1, alpha0, beta1, beta0], T, Acc, value_i, p1,p2,p3,      Z]

    ## Multiply shifted term
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, - T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_Acc, 0, value_i, p1,p2,p3,      Z]
    # Where (prod0_g, prod1_g) =  (value_i - T_i(gz)_0, - T_i(gz)_1) * alpha = (T_i(x) - T_i(gz)) * alpha

    ## Multiply the non shifted term
    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_i, p1,p2,p3,      Z]
    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_i, p1,p2,p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta
    movup.7
    movup.7
    dupw.2
    #=> [Acc, prod1_g, prod0_g, prod1, prod0, y, y, y, y, Acc, value_i, p1,p2,p3,      Z]

    # Accumulate
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [Acc3 + prod1, Acc2 + prod0, Acc1 + prod1_g, Acc0 + prod0_g, y, y, y, y, Acc, value_i, p1,p2,p3,      Z]           Acc = [Tz, Tz, Tgz, Tgz]
    #=> [Acc, Y, Y, P,      Z]

    # Prepare for next iteration, if any
    swapw.3
    swapw
    #=> [Y, P, Y, Acc,      Z]
end


#=> [Y, P, Y, Acc,      Z]
export.deep_query_3

    # Get value_i := T_i(x)
    dup.7
    mem_loadw
    #=> [x, value_i, x, x, x, p1, p2, p3, Y, Acc,      Z ]
    swap
    swap.4
    #=> [y, y, y, y, value_i, p1, p2, p3, Y, Acc,      Z ]
    

    # Get T_i(z), T_i(gz)
    dup.5
    mem_loadw
    push.0.0
    dup.7 add.41
    mem_loadw
    drop drop
    neg 
    swap.2
    neg
    #=> [ - T_i(z)_1, T_i(gz)_0, - T_i(gz)_1, T_i(z)_0, value_i, p1, p2, p3, Y, Acc,      Z ]

    # Compute numerator
    swapw
    dup
    movup.6
    sub
    #=> [value_i - T_i(gz)_0, value_i, p1,p2,p3, - T_i(z)_1, - T_i(gz)_1, T_i(z)_0,, Y, Acc,      Z ]
    movdn.7
    swapw
    dup.4
    movup.3
    sub
    swap
    swapw.2
    #=> [Y, value_i, p1,p2,p3, T, Acc,      Z]      where T := [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0]

    # Multiply by random coefficients
    ## Get [alpha1, alpha0, beta1, beta0]
    dup.6
    add.1
    swap.7
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_i, p1,p2,p3, T, Acc,      Z]
    swapdw
    movupw.2
    #=> [[alpha1, alpha0, beta1, beta0], T, Acc, value_i, p1,p2,p3,      Z]

    ## Multiply the shifted term
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, - T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_Acc, 0, value_i, p1,p2,p3,      Z]
    # Where (prod0_g, prod1_g) =  (value_i - T_i(gz)_0, - T_i(gz)_1) * alpha = (T_i(x) - T_i(gz)) * alpha
    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_i, p1,p2,p3,      Z]

    ## Multiply the non-shifted term
    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_i, p1,p2,p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta
    movup.7
    movup.7
    dupw.2
    #=> [Acc, prod1_g, prod0_g, prod1, prod0, y, y, y, y, Acc, value_i, p1,p2,p3,      Z]

    # Accumulate
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [Acc3 + prod1, Acc2 + prod0, Acc1 + prod1_g, Acc0 + prod0_g, y, y, y, y, Acc, value_i, p1,p2,p3,      Z]           Acc = [Tz, Tz, Tgz, Tgz]
    #=> [Acc, Y, Y, P,      Z]

    # Prepare for next iteration, if any
    swapw.3
    swapw
    #=> [Y, P, Y, Acc,      Z]
end

#=> [Y, P, Y, Acc,      Z]
export.deep_query_4

    # Get value_i := T_i(x)
    ## update pointer for potential next iteration
    dup.7
    add.1
    swap.8
    ## Load correct value
    mem_loadw
    #=> [value_i, x, x , x, x, p1,p2,p3, Y, Acc,      Z ]
    swap.4
    #=> [Y, value_i, p1,p2,p3, Y, Acc,      Z ]
    

    # Get T_i(z), T_i(gz)
    dup.5
    mem_loadw
    movup.3
    movup.3
    push.0.0
    dup.7 add.41
    mem_loadw
    movup.3
    movup.3
    drop drop
    neg 
    swap.2
    neg
    #=> [ - T_i(z)_1, T_i(gz)_0, - T_i(gz)_1, T_i(z)_0, value_i, p1, p2, p3, Y, Acc,      Z ]

    # Update p1 (since `deep_query_4` is the last `deep_query_X` procedure in the 4-procedure cycle)
    movup.5
    add.1
    movdn.5


    # Compute numerator
    swapw
    dup
    movup.6
    sub
    #=> [value_i - T_i(gz)_0, value_i, p1,p2,p3, - T_i(z)_1, - T_i(gz)_1, T_i(z)_0,, Y, Acc,      Z ]
    movdn.7
    swapw
    dup.4
    movup.3
    sub
    swap
    swapw.2
    #=> [Y, value_i, p1,p2,p3, T, Acc,      Z]      where T := [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0]

    # Multiply by randomness
    ## Get [alpha1, alpha0, beta1, beta0]
    dup.6
    add.1
    swap.7
    mem_loadw
    #=> [[alpha1, alpha0, beta1, beta0], value_i, p1,p2,p3, T, Acc,      Z]
    swapdw
    movupw.2
    #=> [[alpha1, alpha0, beta1, beta0], T, Acc, value_i, p1,p2,p3,      Z]

    ## Multiply shifted term
    dup.7
    dup.7
    ext2mul
    #=> [prod1_g, prod0_g, beta1, beta0, - T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_Acc, 0, value_i, p1,p2,p3,      Z]
    # Where (prod0_g, prod1_g) =  (value_i - T_i(gz)_0, - T_i(gz)_1) * alpha = (T_i(x) - T_i(gz)) * alpha
    swap
    swap.3
    swap
    swap.2    
    swapw
    #=> [- T_i(z)_1, value_i - T_i(z)_0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_i, p1,p2,p3,      Z]

    ## Multiply non-shifted term
    dup.5
    dup.5
    ext2mul
    #=> [prod1, prod0, - T_i(gz)_1, value_i - T_i(gz)_0, beta1, beta0, prod1_g, prod0_g, Acc, value_i, p1,p2,p3,      Z]
    # where (prod0, prod1) =  (value_i - T_i(z)_0, - T_i(z)_1) * beta = (T_i(x) - T_i(z)) * beta
    movup.7
    movup.7
    dupw.2
    #=> [Acc, prod1_g, prod0_g, prod1, prod0, y, y, y, y, Acc, value_i, p1,p2,p3,      Z]

    # Accumulate
    movup.7
    movup.7
    ext2add
    movdn.5
    movdn.5
    ext2add
    swap
    swap.3
    swap
    swap.2
    #=> [Acc3 + prod1, Acc2 + prod0, Acc1 + prod1_g, Acc0 + prod0_g, y, y, y, y, Acc, value_i, p1,p2,p3,      Z]           Acc = [Tz, Tz, Tgz, Tgz]
    #=> [Acc, Y, Y, P,      Z]

    # Prepare for next cycle, if any
    swapw.3
    swapw
    #=> [Y, P, Y, Acc,      Z]
end