use.std::crypto::fri::frie2f4
use.std::crypto::fri::ext2fri

use.std::crypto::stark::deep_queries
use.std::crypto::stark::random_coin



# <= [log2(domain_size), ..]
# => [domain_gen, ..]
export.compute_generator
    push.32
    swap
    sub
    pow2
    push.7277203076849721926
    swap
    exp.u64
    # => [domain_gen, ..]
end

# <= [lde_size, 1, ..]
# => [remainder_size, lde_size, num_fri_layers,..]
export.get_num_fri_layers
    dup
    push.4
    u32checked_divmod

    dup.1
    push.0
    neq

    while.true
        drop
        movup.2
        add.1
        movdn.2

        push.4
        u32checked_divmod

        dup.1
        push.64
        u32unchecked_gt
    end
    drop
end

#<= [a, ..]
#=> [log2(a), ..]
proc.log2
    push.1
    swap
    push.2
    dup.1
    dup.1
    neq
    while.true
        swap.2
        add.1
        swap.2
        #=> [2^cnt, a, cnt, ..]
        mul.2
        dup.1
        dup.1
        neq
    end
    push.0
    swap.3
    swap
    push.0
    swap.3
    drop
    #=> [a, log2(a), y, y]
end

#================================================
#   Memory layout:
#   0. Seed
#   1. [lde_size, log2(lde_size), 0, 0]
#   2. Main trace commitment
#   3. Aux trace commitment
#   4. Constraint polynomial columns trace commitment
#   5. [lde_size, log2(lde_size), lde_domain_generator, 0]
#   6. [num_fri_layers, remainder_size, lde_size, lde_domain_generator]
#   7. Remainder commitment
#   8. Intermidiate values.
#   9. [lde_size, log2(lde_size), lde_domain_generator, 0] (same as 5 but for a different purpose)
#   10.[gz1, gz0, z1, z0]
#   11.[x, _, _, _] where x := offset * lde_domain_generator^query_index
#   20. [0, 0, 0, 1] used for hmerge in case the number of elements to be hashed is not divisible by 8
#   21. [0, 0, 0, 0] used for hmerge in case the number of elements to be hashed is divisible by 8
#   22 -> 1999 Empty for now but should hold the public inputs in the future
#   2000 -> 2015    auxiliary trace random coefficients
#   2016 -> 2250    constraint composition coefficients
#   2251    [(z^8)_1, (z^8)_0, z_1, z_0] where z = (z_0, z_1) is the OOD random element
#   2252 -> 2292    current row of the OOD evaluation frame 
#   2293 -> 2333    next row of the OOD evaluation frame 
#   2334 -> 2337    value_i for i in 0..=7 where H(z) := \sum_0^7 value_i * z^i and H is the constraint compostion polynomial
#   2338 -> 2463    Deep query coefficients
#   2473 -> 2499    [0, query, evaluation_1, evaluation_0] for the 27 FRI queries
#   2500 -> ptr_remainder - 1 where ptr_remainder := 2500 + 2 * number_of_layers
#   ptr_remainder -> ptr_remainder + remainder_length / 2
#   ptr_remainder + remainder_length / 2 + 1 -> ptr_remainder + remainder_length / 2 + length_of_remainder_polynomial/2
#================================================

# Notes: 
# 1. The choice of the number of locals is based on an estimate and should be updated  
# 2. Once `RandomCoin` has been redesigned, the way randomness is generated should be simplified.
# 3. The periodic values for the OOD evaluation frame are not implemented. This should probably be
#   delegated to the constraint evaluator.  
# 4. Unless otherwise stated, `x`, `X`, `y` and `Y` denote "garbage" values on the stack. When computing
#   the deep evaluation queries, `x` will denote `offset * g^index`.  
export.verify.4222

    # Create the initial seed for randomness generation
    # The following expects the input stack to be of size 16
    ## Proof context (except trace length)
    push.1208027408
    push.1
    push.4294967295
    push.132103
    push.16             
    push.8              
    push.27             

    ## trace length
    adv_push.1

    ## Compute log2(lde_domain_length) and save it for later use
    dup
    ### Multiply by blowup factor
    mul.8
    ### Compute log and store
    exec.log2
    loc_storew.1
    dropw
    
    ## Hash proof context
    push.1.0.0.0
    #=> [0, 0, 0, 1, B, A, ProgRoot]
    swapw.2
    swapw
    #=> [B, A, 0, 0, 0, 1, ProgRoot]
    hperm
    #=> [Y, Y, C, ProgRoot]

    ## Hash i/o stack
    swapw.3
    swapw
    #=> [Y, ProgRoot, C, Y, ]
    adv_loadw
    hperm
    repeat.3
    adv_loadw
    swapw
    adv_loadw
    hperm
    end
    adv_loadw
    swapw
    dropw
    push.1.0.0.0
    hperm
    swapdw
    dropw
    dropw


    # Load main trace commitment and re-seed with it
    adv_loadw           #=> [main_trace_commitment, Seed]
    loc_storew.2
    swapw
    exec.random_coin::reseed         
    locaddr.0
    mem_storew          
    # => [Seed_n, X, Y]

    # Draw random ExtFelt for the auxiliary trace
    # From locaddr.2000 to 2015 we have the aux randomness
    locaddr.2000
    movdn.4
    push.1
    movdn.4         
    # => [Seed, 1, ptr_rand_cstr_coef]

    repeat.16
        exec.random_coin::generate_next_extfelt
        loc_loadw.0
        # => [Seed, 2, ptr + 1, X, Y]
    end


    # Reseed with auxiliary trace commitment
    swapw
    adv_loadw
    loc_storew.3
    swapw               #[Seed, AuxCom, x, x, Y, Y]
    exec.random_coin::reseed         #[Seed_n, Y, Y, x, x, Y, Y]
    loc_storew.0

    # TODO: make use of these
    dropw dropw dropw  
    

    # Draw constraint composition coefficients
    # From `ptr_compos_coef = locaddr.2016` to 2250 (inclusive) we have the constraint 
    # composition random coefficients.
    # They are ordered in increasing index order and when loaded into the stack ordered as
    # (r1_1, r1_0, r0_1, r0_0)
    # TODO: Double check that this is the exact number of random coefficients we need.
    push.0.0
    loc_loadw.0
    locaddr.2016
    movdn.4
    push.1
    movdn.4         
    # => [Seed, 1, ptr_compos_coef]

    repeat.235
        exec.random_coin::generate_next_extfelt_tuple
        loc_loadw.0
        # => [Seed, 2, ptr + 1]
    end
    # => [Seed, x, x]


    # Reseed with constraint composition polynomial commitment
    swapw
    adv_loadw
    loc_storew.4
    swapw
    exec.random_coin::reseed
    loc_storew.0
    #=> [Seed_n, X, Y, ]


    # Draw OOD z
    push.1.0.0.0
    loc_storew.20
    swapw
    push.1.1.0.0
    hperm

    # TODO: optimize this
    dropw
    swapw
    dropw 
    swapw
    dropw

    # Store OOD challenge z and z^8 so that when it is loaded on stack as [z^8_1, z^8_0, z1, z0]
    drop drop
    dup.1
    dup.1
    repeat.3
        dup.1
        dup.1
        ext2mul
    end
    loc_storew.2251
    # => [X, Y, x, x, 0, 0, 0, 0, 0, 0]


    # Read [ood_main_trace_frame.current(), aux_trace_frame.current()]
    # We have 72 main trace columns and 9 aux trace columns for a total of 162 base field elements
    # 162 = 20 * 8 + 2
    # [ood_main_trace_frame.current(), aux_trace_frame.current()] is stored in locaddr.2252 to locaddr.2292.
    # They are stored from the stack as (a1_1, a1_0, a0_1, a0_0) except for locaddr.2292
    # which is stored from the stack as (a1, a0, 1, 0)
    locaddr.2252
    movdn.8
    push.1.0.0.0
    swapw.2
    repeat.20
        adv_pipe
    end

    # adv_pipe the last two elements
    dropw dropw
    adv_push.1
    adv_push.1
    push.1
    push.0
    loc_storew.2292
    push.0.0.0.0
    loc_storew.21
    hperm
    # => [X, Digest_current, X, ptr]

    # Reseed
    loc_loadw.0
    exec.random_coin::reseed
    loc_storew.0
    # => [Seed_n, X, X, X, ptr]
    
    # TODO: optimize this
    dropw dropw drop drop drop
    # => [X, X, ..]

    # Read [ood_main_trace_frame.next(), aux_trace_frame.next()]
    # We have 72 main trace columns and 9 aux trace columns for a total of 162 base field elements
    # 162 = 20 * 8 + 2
    # [ood_main_trace_frame.next(), aux_trace_frame.next()] is stored in locaddr.2293 to locaddr.2333.
    # They are stored from the stack as (a1_1, a1_0, a0_1, a0_0) except for locaddr.2333
    # which is stored from the stack as (a1, a0, 1, 0)
    locaddr.2293
    movdn.8
    push.1.0.0.0
    swapw.2
    repeat.20
        adv_pipe
    end

    # adv_pipe the last two elements
    dropw dropw
    adv_push.1
    adv_push.1
    push.1
    push.0
    loc_storew.2333
    push.0.0.0.0
    hperm
    # => [X, Digest_current, X, ptr]

    # Reseed
    loc_loadw.0
    exec.random_coin::reseed
    loc_storew.0
    # => [Seed_n, X, X, X, ptr]

    # Read OOD constraint evaluations. These are 8 ExtFelt `value_i` such that the value of
    # constraint evaluation function at `z` `H(z)` equals `\sum_0^7 z^i value_i`.
    # The values are stored from locaddr.2334 to locaddr.2337
    locaddr.2334
    movdn.8
    push.0.0.0.0
    swapw.2
    adv_pipe
    adv_pipe

    # Reseed
    loc_loadw.0
    exec.random_coin::reseed
    loc_storew.0
    # => [Seed_n, X, X, X, ptr]

    # Compute `H(z)`
    ## Load `value_i`'s
    loc_loadw.2334
    swapw.3
    loc_loadw.2335
    swapw.2
    loc_loadw.2336
    swapw
    loc_loadw.2337

    ## Load z
    push.0.0.0.0
    loc_loadw.2251
    drop drop
    # => [z1, z0, value_7, ... ,value_0]

    # Horner evaluation
    # TODO: maybe can be done faster in another way
    repeat.6
        dup
        movdn.6
        dup.1
        movdn.7
        # => [z1, z0, value_7, value_6, z1, z0, value_5, ... ,value_0]

        ext2mul
        ext2add
        # => [acc1, acc0, z1, z0, value_5, ... ,value_0]

        movup.3
        movup.3
        # => [z1, z0, acc1, acc0, value_5, ... ,value_0]
    end
    ext2mul
    ext2add
    # => [res1, res0, x, x, X, X, 0, 0, 0, 0]

    # TODO: Compare with the evaluation of the constraints on the EvaluationFrame


    # Draw deep composition polynomial coefficients
    ## Load Seed and prepare for drawing
    loc_loadw.0
    locaddr.2338
    movdn.4
    push.1
    movdn.4
    # => [Seed, 1, ptr, X, X, 0, 0, 0, 0]

    ## Draw the random coefficients
    ## The number of coefficients is equal to:
    ## (72 + 9) * 4 Felt for the trace.
    ## 8 * 2 Felt for constraint polynomial.
    ## 2 Felt for degree correction.
    ## Total: 172 tuples of type (Felt, Felt)
    repeat.86
        exec.random_coin::generate_next_extfelt_tuple
        loc_loadw.0
        # => [Seed, 3, ptr + 1]
    end
    # => [Seed, 172, ptr + 1, X, X, 0, 0]


    #============================================
    #       FRI verification
    #============================================
    # Load  FRI verifier data:
    # [0, 0, lde_size, log2(lde_size)]
    loc_loadw.1

    # Compute lde_domain generator
    dup.1
    exec.compute_generator
    #=> [g, lde_size, log2(lde_size), 0, 0]
    movdn.2
    #=> [log2(lde_size), lde_size, g, 0, 0]
    loc_storew.5


    # Compute [gz1, gz0, z1, z0] using domain generator
    # TODO: move to somewhere else
    push.0.0.0.0
    loc_loadw.2251
    drop drop
    dup.1
    dup.1
    dup.6
    
    # Compute trace_domain_generator
    repeat.3
        dup mul
    end
    dup
    movup.3
    mul
    swap.2
    mul
    loc_storew.10
    dropw

    # TODO: remove the need for this
    loc_storew.9
    # => [lde_size, log2(lde_size), lde_generator, 0, 0]

    # Compute the number of FRI layers
    dup
    push.1
    swap
    # => [lde_size, 1, ..]
    exec.get_num_fri_layers
    movup.2
    # => [num_fri_layers, remainder_size, lde_size, lde_size, log2(lde_size), domain_gen, 0, 0, X, X]
    
    # Save [num_fri_layers, remainder_size, lde_size, domain_gen] in memory
    loc_storew.6


    # Get FRI layer commitments and reseed to draw folding challenges i.e. alphas
    
    locaddr.2500    # Address containing the first layer commitment
    swap.2 drop     
    # => [num_layers, ptr_layer, x, x, X, X, X,       x, x]
    
    dup
    push.0
    neq
    while.true
        swapw               # [X, num_layers, ptr_layer, x, x, X, X]
        adv_loadw           # [Com, num_layers, ptr_layer, x, x, X, X]

        # Save commitment
        dup.5
        add.1
        swap.6
        mem_storew

        # Reseed
        movupw.2
        loc_loadw.0         # [Seed, Com, num_layers, ptr_layer + 1, x, x, X]
        exec.random_coin::reseed
        loc_storew.0
        # => [Seed_n, X, Y, num_layers, ptr_layer + 1, x, x, X]

        # TODO: save the padding of hperm and use X, Y just above to loc_loadw on top of them
        swapw.2
        dropw dropw
        push.1.0.0.0
        swapw
        push.1.1.0.0
        # => [0, 0, 1, 1, Seed, 0, 0, 0, 1, num_layers, ptr_layer + 1, x, x, X]
        hperm                  #[X, Res, Y,  num_layers, ptr_layer + 1, x, x, X]
        drop drop
        loc_loadw.5
        # => [lde_size, log2(lde_size), lde_generator, 0, a1, a0, Y, num_layers, ptr_layer + 1, x, x, X]

        # Compute new lde_size and its new log
        div.4
        swap
        sub.2
        swap
        loc_storew.5

        # Move the pointer higher 
        movup.2 drop
        movup.2 drop
        swapw
        movdnw.2
        # => [lde_size, log2(lde_size), a1, a0, num_layers, ptr_layer + 1, x, x, Y, X]

        # Save [lde_size, log2(lde_size), a1, a0] in memory next to the layer commitment
        dup.5
        add.1
        swap.6
        mem_storew
        swapw
        # => [num_layers, ptr_layer + 1, x, x, lde_size, log2(lde_size), a1, a0, Y, X]

        # Decrement the FRI layer counter
        sub.1
        dup
        push.0
        neq
    end
    # => [0, ptr_layer + 2*num_layers, X, X, X, X]
    # => [0, ptr_remainder, X, X, X, X] where ptr_remainder := ptr_layer + 2*num_layers

    # Shuffle the stack 
    swap
    swapw.3
    # => [y, y, y, y, X, X, ptr_remainder, 0, x, x,     x, x]

    # Load remainder commitment and save it at locaddr.7
    # TODO: remove the part related to remainder commitment after the next Winterfell release
    adv_loadw
    loc_storew.7

    # Reseed with remainder commitment
    swapw
    loc_loadw.0
    exec.random_coin::reseed
    loc_storew.0
    # => [Seed_n, X, X, X, ptr_remainder, 0, x, x,     x, x]

    # adv_pipe the remainder codeword
    ## Get the length of remainder
    loc_loadw.6
    locaddr.2500
    swap
    mul.2
    add
    loc_storew.8
    # => [ptr_remainder, remainder_size, x, x, X, X, X, ptr_remainder, 0, x, x,     x, x]

    dup.1
    push.32
    eq
    if.true
        # Remainder length equal to 32
        swapw.3
        loc_loadw.21    # load [0, 0, 0, 0] from memory
        swapw.2
        # => [X, X, 0, 0, 0, 0 ptr_remainder, remainder_size, x, x, ptr_remainder, 0, x, x,     x, x]
        
        # adv_load remainder polynomial
        # TODO: This is a workaround since the FRI verifier expects the memory layout to be 
        # [query_ptr ... layer_ptr ... rem_ptr ...] which leaves only one option for laying out 
        # the polynomial coefficients i.e. starting at remainder_ptr + remainder_codeword_length/2.
        # On the other hand, we need to check that the hash of the polynomial coefficients agrees with
        # the commitment already received by the prover. Thus the need for hashing the polynomial
        # coefficients first.
        # Also, this is redundant now since `verify_remainder_32` recomputes the polynomial coefficients
        # from the remainder codeword.
        adv_loadw
        dup.12
        add.16
        mem_storew
        swapw
        adv_loadw
        dup.12
        add.17
        mem_storew
        hperm
        # => [X, remainder_poly_com, Y, ptr_remainder, remainder_size, x, x, ptr_remainder, 0, x, x,     x, x]

        # Compare remainder_poly_com with the read commitment
        loc_loadw.7
        movup.4
        assert_eq
        movup.3
        assert_eq
        movup.2
        assert_eq
        assert_eq
        # => [Y, ptr_remainder, remainder_size, x, x, ptr_remainder, 0, x, x, x, x, 0, 0]
        swapdw
        repeat.8
            adv_pipe
        end
    else
        # Remainder length equal to 64
        swapw.3
        loc_loadw.21    # load [0, 0, 0, 0] from memory
        swapw.2
        # => [X, X, 0, 0, 0, 0 ptr_remainder, remainder_size, x, x, ptr_remainder, 0, x, x,     x, x]
        
        # adv_load remainder polynomial
        # TODO: This is a workaround since the FRI verifier expects the memory layout to be 
        # [query_ptr ... layer_ptr ... rem_ptr ...] which leaves only one option for laying out 
        # the polynomial coefficients i.e. starting at remainder_ptr + remainder_codeword_length/2.
        # On the other hand, we need to check that the hash of the polynomial coefficients agrees with
        # the commitment already received by the prover. Thus the need for hashing the polynomial
        # coefficients first.
        # Also, this is redundant now since `verify_remainder_64` recomputes the polynomial coefficients
        # from the remainder codeword.
        adv_loadw
        dup.12
        add.32
        mem_storew
        swapw
        adv_loadw
        dup.12
        add.33
        mem_storew
        hperm

        adv_loadw
        dup.12
        add.34
        mem_storew
        swapw
        adv_loadw
        dup.12
        add.35
        mem_storew
        hperm
        # => [X, remainder_poly_com, Y, ptr_remainder, remainder_size, x, x, ptr_remainder, 0, x, x,     x, x]

        # Compare remainder_poly_com with the read commitment
        loc_loadw.7
        movup.4
        assert_eq
        movup.3
        assert_eq
        movup.2
        assert_eq
        assert_eq
        # => [Y, ptr_remainder, remainder_size, x, x, ptr_remainder, 0, x, x, x, x, 0, 0]
        swapdw
        repeat.16
            adv_pipe
        end
    end
    # => [X, R, Y, X] where R = [x, x, tau1, tau0]
    
    # Prepare for remainder verification procedure
    drop drop
    loc_loadw.8
    # => [ptr_remainder, remainder_size, x, x, tau1, tau0, X, X]

    # Call the correct remainder verification procedure
    swap
    push.32
    eq
    if.true
        # TODO: Modify verify_remainder_32 so that it uses (tau0, tau1) instead of 
        # recomputing them again.
        # For the moment, we drop the word containing (tau0, tau1).
        movdn.4 dropw
        exec.ext2fri::verify_remainder_32
    else
        # TODO: Modify verify_remainder_64 so that it uses (tau0, tau1) instead of 
        # recomputing them again.
        # For the moment, we drop the word containing (tau0, tau1).
        movdn.4 dropw
        exec.ext2fri::verify_remainder_64
    end

    # Check PoW nonce
    ## Load Seed
    loc_loadw.0
    push.1.0.0.0
    swapw
    adv_push.1
    push.1.0.0
    hperm
    swapw
    loc_storew.0

    ## Get the leading field element of the digest
    swap.3

    ## Make sure the lower 16 bits are zero
    u32split
    swap
    push.0xFFFF
    u32checked_and
    assertz

    # Draw random query indices
    ## Put the pointer to the integers on the stack
    drop 
    locaddr.2473
    swap.3
    swapw.3
    push.0
    
    ## Create mask
    loc_loadw.9
    sub.1

    ## Get address holding the integers
    locaddr.2473
    push.1
    swapw
    loc_loadw.0
    # => [Seed, 1, ptr_integers, mask, depth, x, X, X,    x, x] where depth = log(lde_size)


    ## Draw the random queries
    ## TODO: the case of duplicate queries 
    exec.random_coin::generate_next_integer
    repeat.26
        loc_loadw.0
        exec.random_coin::generate_next_integer
    end
    # => [X, X, X, X, x, x]

    # Note: From now on, only Y and y denote garbage values.
    push.1.1
    locaddr.2473
    #=>[ptr_query, Y, Y, Y, Y, Y, ptr_query]
    repeat.27       
        
        # Main trace portion of the query
        ## Get main trace commitment and use it to get the leaf
        mem_loadw
        swapw
        loc_loadw.2
        swapw
        loc_storew.14
        movup.2 drop
        movup.2 drop
        swap
        #=> [d, query, Com, Y, Y]
        mtree_get
        loc_storew.13
        adv.keyval
        #=> [V, R, Y, Y]  
        drop
        locaddr.2800
        swapw.3
        #=> [Y, Y, Y, ptr, y, y, y ]
        loc_loadw.21
        swapw.2
        #=> [Y, Y, 0, 0, 0, 0, ptr, y, y, y]
        repeat.9
            adv_pipe
        end
        #=> [Y, L, Y, ptr, y, y, y]

        ## Load the leaf value we got using mtree_get
        loc_loadw.13

        ## Check correctness of unhashing
        movup.4
        assert_eq
        movup.3
        assert_eq
        movup.2
        assert_eq
        assert_eq
        #=>[Y, ptr, y, y, y]

        swapw
        swap.3
        push.0
        loc_loadw.14
        movup.2 drop
        movup.3
        swapw
        #=>[Y, ptr, pos, depth, y]
        
        # Aux trace part
        ## Load aux trace commitment and get leaf
        loc_loadw.3
        dup.5
        dup.7
        mtree_get
        adv.keyval
        loc_storew.13
        #=> [L, R, ptr, pos, depth, 0, ]

        ## Prepare for adv_pipe aux trace row
        loc_loadw.20
        swapw
        push.0.0.0.0
        adv_pipe
        adv_pipe
        dropw
        adv_push.1
        adv_push.1
        push.1
        push.0
        loc_storew.2822
        swapw
        loc_loadw.21
        hperm
        #=> [Y, L, Y, ptr, pos, depth, y]
        loc_loadw.13
        ## Check correctness of unhashing
        movup.4
        assert_eq
        movup.3
        assert_eq
        movup.2
        assert_eq
        assert_eq
        #=> [Y, ptr, pos, depth, y]

        ## Update pointer
        swapw
        add.1
        swapw

        # Constraint composition trace part
        ## Load commitment constraint trace and get leaf
        loc_loadw.4
        dup.5
        dup.7
        mtree_get
        adv.keyval
        loc_storew.13
        #=>[L, R, ptr, pos, depth, y]
        loc_loadw.21
        swapw
        push.0.0.0.0
        adv_pipe
        adv_pipe
        #=> [Y, L, Y, ptr, pos, depth, y,       y, y]

        ## Check correctness of unhashing
        loc_loadw.13
        movup.4
        assert_eq
        movup.3
        assert_eq
        movup.2
        assert_eq
        assert_eq
        #=> [Y, ptr, pos, depth, y, y, y, y, ]

        # TODO: avoid this
        swapw
        swap
        movdn.3
        #=> [ptr, depth, y, pos, Y, y, y, y, ]
        
        # Load domain_gen    
        push.0
        loc_loadw.9
        #=> [lde_size, depth, domain_gen, 0, pos, y, y, y, Y, ]

        # Compute x = offset * domain_gen^pos
        movup.2
        dup.4
        exp.u32
        mul.7
        loc_storew.11       # Store x for much later use
        #=> [x, lde_size, depth, 0, pos, y, y, y, Y, ]
        swapw
        #=> [pos, y, y, y, x, lde_size, depth, 0, Y, ]

        # Compute the denominator i.e. (x - z) and (x - gz) 
        ## Get z and gz from memory
        loc_loadw.10
        #=> [gz1, gz0, z1, z0, x, lde_size, depth, 0, Y, ]
        neg
        dup.4
        movup.2
        sub
        movdn.4
        movdn.3
        #=> [z1, z0, x, -gz1, x -gz0, ..]

        ## Compute Z := [-z1, x - z0, -gz1, x -gz0] 
        neg
        movdn.2
        sub
        swap
        #=> [Z, Y, Y] where Z := [-z1, x - z0, -gz1, x -gz0] 

        ## Move Z to the last portion of the stack
        push.0
        movdn.4
        swapw.2
        #=> [Y, Y, Z]

        # Get pointers
        locaddr.2800    # p3 := ptr_trace
        locaddr.2338    # p2 := ptr_coef
        locaddr.2252    # p1 := ptr_ood_frame current. Next is 2293 i.e. 41 words offset
        push.0
        #=> [P, x, lde_size, depth, 0, pos, y, y, y, Y, ]

        # Prepare to compute the sum \sum_{i=0}^k{\left(\alpha_i \cdot \frac{T_i(x) - T_i(z)}{x - z} 
        #            + \beta_i \cdot \frac{T_i(x) - T_i(z \cdot g)}{x - z \cdot g}
        # We can factorize (x - z) and (x - gz) and divide the two sums only once at the end.
        # The two sums are stored in [Acc3, Acc2] and [Acc1, Acc0] respectively.

        # This will contain the two accumulators
        push.0.0.0.0    
        swapw.3
        #=> [Y, P, Y, 0, 0, 0, 0,      Z ]
        #=> [Y, P, Y, Acc,       Z] where Acc =: [Acc3, Acc2, Acc1, Acc0]

        # Loop over i (constraints) for the currently fixed x 
        # There are 72 columns in the main trace. In each iteration of the following loop we are treating 
        # 4 columns and thus need 18 iterations.
        # The reason for having 4 different (almost) identical implementations for `proc.deep_query`
        # is due to the fact that T_i(x) is a base field element and can be in 1 of 4 possible
        # locations at a memory location. To avoid expensive pointer arithmetic we opted to have
        # one implementation for each of the 4 possiblities.
        repeat.18
        exec.deep_queries::deep_query_1
        exec.deep_queries::deep_query_2
        exec.deep_queries::deep_query_3
        exec.deep_queries::deep_query_4
        end

        # Next is the auxiliary columns. Since the aux trace has elements in the extension field we need
        # to give up one of the pointers in order to fit everything on the stack. Since the trace-row
        # currently being processed is always held in the temporary contiguous memory region pointed to
        # by locaddr.2800, we can just drop p1 and unroll the loop into as many aux trace columns as needed.
        # Currently, we have 9 such columns and thus the following 9 similar code-blocks.
        #<= [Y, 0, p1, p2, p3, Y, Acc,      Z ]
        swapw
        movup.3
        #=> [p3, 0, p2, p3, Y, Y, Acc,      Z ]
        #=> [y, y, p2, p3, Y, Y, Acc,      Z]

        # Load the 1st, out of 9, auxiliary trace values 
        push.0.0
        loc_loadw.2818
        #=> [value_{i+1}1, value_{i+1}0, value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,      Z ]
        drop drop
        #=> [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,      Z ]
        exec.deep_queries::deep_query_aux_1

        # Load the 2nd out of 9, auxiliary trace values 
        push.0.0
        loc_loadw.2818
        #=> [value_{i+1}1, value_{i+1}0, value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,      Z ]
        movup.2 drop
        movup.2 drop
        #=> [value_{i+1}1, value_{i+1}0, p1, p2, Y, Y, Acc,      Z ]
        exec.deep_queries::deep_query_aux_2

        # Load the 3rd out of 9, auxiliary trace values 
        push.0.0
        loc_loadw.2819
        drop drop
        exec.deep_queries::deep_query_aux_1

        # Load the 4th out of 9, auxiliary trace values 
        push.0.0
        loc_loadw.2819
        movup.2 drop
        movup.2 drop
        exec.deep_queries::deep_query_aux_2

        # Load the 5th out of 9, auxiliary trace values 
        push.0.0
        loc_loadw.2820
        drop drop
        exec.deep_queries::deep_query_aux_1

        # Load the 6th out of 9, auxiliary trace values 
        push.0.0
        loc_loadw.2820
        movup.2 drop
        movup.2 drop
        exec.deep_queries::deep_query_aux_2

        # Load the 7th out of 9, auxiliary trace values 
        push.0.0
        loc_loadw.2821
        drop drop
        exec.deep_queries::deep_query_aux_1

        # Load the 8th out of 9, auxiliary trace values 
        push.0.0
        loc_loadw.2821
        movup.2 drop
        movup.2 drop
        exec.deep_queries::deep_query_aux_2

        # Load the 9th out of 9, auxiliary trace values 
        push.0.0
        loc_loadw.2822
        drop drop
        exec.deep_queries::deep_query_aux_1
        #=> [value_{i}1, value_{i}0, p1, p2, Y, Y, Acc,      Z ]

        # Move p2, the pointer to constraint random coefficients, further up the stack and prepare 
        # for loading the composition constraint polynomial part by getting the next two H_i(x) 
        # i.e. the constraint composition trace row i.e. H_i(x) and H_{i+1}(x) for current x 
        swapw.2
        loc_loadw.2823    
        #=> [H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, Y, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]

        # Get OOD constraint evaluation frame for i = 0
        swapw
        loc_loadw.2334
        #=> [H_{i+1}(z)_1, H_{i+1}(z)_0, H_{i}(z)_1, H_{i}(z)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1,
        #    H_{i}(x)_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]


        # Compute H_i(x) - H_i(z) and H_{i+1}(x) - H_{i+1}(z)
        movup.5
        movup.5
        swapw
        #=> [H_{i}(z)_1, H_{i}(z)_0, H_{i}(x)_1, H_{i}(x)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0,
        #    value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        ext2sub
        #=> [H_{i}_1, H_{i}_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0,
        #    value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        # where (H_{i}_0, H_{i}_1) = (H_{i}(x)_0 - H_{i}(z)_0, H_{i}(x)_1 - H_{i}(z)_1)
        movdn.5
        movdn.5
        ext2sub
        neg
        swap
        neg
        swap
        #=> [H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        # where (H_{i+1}_0, H_{i+1}_1) = (H_{i+1}(x)_0 - H_{i+1}(z)_0, H_{i+1}(x)_1 - H_{i+1}(z)_1)

        # Load the random coefficients and compute the two products for i and i+1
        swapw
        push.0.0.0.0
        dup.7
        add.1
        swap.8
        mem_loadw
        #=> [delta_{i+1}_1, delta_{i+1}_0, delta_{i}_1, delta_{i}_0, value_{i}1, value_{i}0, p2, p1, 
        #   H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, Acc,      Z ]

        movupw.2
        movup.5
        movup.5
        #=> [delta_{i+1}_1, delta_{i+1}_0, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0,
        #    value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        ext2mul
        #=> [prod_{i+1}_0, prod_{i+1}_1, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0,
        #    value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        # where (prod_{i+1}_0, prod_{i+1}_1) = (H_{i+1}_0, H_{i+1}_1) * delta_{i+1}

        movdn.5
        movdn.5
        #=> [H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, prod_{i+1}_1, prod_{i+1}_0, 
        #   value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        ext2mul
        movdn.3
        movdn.3
        #=> [prod_{i+1}_1, prod_{i+1}_0, prod_i_1, prod_i_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        # where (prod_{i}_0, prod_{i}_1) = (H_{i}_0, H_{i}_1) * delta_{i}

        # Accumulate partial sum 
        ext2add
        #=> [prod_{i+1}_1 + prod_i_1, prod_{i+1}_0 + prod_i_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        #=> [accH_1, accH_0, value_{i}1, value_{i}0, p2, p1, Acc,      Z ]
        # where (accH_0, accH_1) = (prod_{i+1}_0 + prod_i_0, prod_{i+1}_1 + prod_i_1)

        # load next H_i(x) and H_{i+1}(x) for current x i.e. i = 2
        movup.3
        movup.3
        push.0.0
        loc_loadw.2824
        #=> [H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        # load next H_i(z) and H_{i+1}(z)
        push.0.0.0.0
        loc_loadw.2335
        #=> [H_{i+1}(z)_1, H_{i+1}(z)_0, H_{i}(z)_1, H_{i}(z)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0,
        #    accH_1, accH_0, p2, p1, Acc,      Z ]

        # Compute H_i(x) - H_i(z) and H_{i+1}(x) - H_{i+1}(z)
        movup.5
        movup.5
        swapw
        #=> [H_{i}(z)_1, H_{i}(z)_0, H_{i}(x)_1, H_{i}(x)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0,
        #    accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2sub
        #=> [H_{i}_1, H_{i}_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i}_0, H_{i}_1) = (H_{i}(x)_0 - H_{i}(z)_0, H_{i}(x)_1 - H_{i}(z)_1)

        movdn.5
        movdn.5
        ext2sub
        neg
        swap
        neg
        swap
        #=> [H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i+1}_0, H_{i+1}_1) = (H_{i+1}(x)_0 - H_{i+1}(z)_0, H_{i+1}(x)_1 - H_{i+1}(z)_1)

        # Load the random coefficients and compute the two products for i and i+1
        swapw
        push.0.0.0.0
        dup.7
        add.1
        swap.8
        mem_loadw
        #=> [delta_{i+1}_1, delta_{i+1}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, 
        #   H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, Acc,      Z ]

        movupw.2
        movup.5
        movup.5
        #=> [delta_{i+1}_1, delta_{i+1}_0, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, 
        #   accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        #=> [prod_{i+1}_0, prod_{i+1}_1, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, 
        #   accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i+1}_0, prod_{i+1}_1) = (H_{i+1}_0, H_{i+1}_1) * delta_{i+1}

        movdn.5
        movdn.5
        #=> [H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, prod_{i+1}_1, prod_{i+1}_0, 
        #   accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        movdn.3
        movdn.3
        #=> [prod_{i+1}_1, prod_{i+1}_0, prod_i_1, prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i}_0, prod_{i}_1) = (H_{i}_0, H_{i}_1) * delta_{i}

        # Accumulate
        ext2add
        #=> [prod_{i+1}_1 + prod_i_1, prod_{i+1}_0 + prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2add
        #=> [accH_1, accH_0, p2, p1, Acc,      Z ]

        # load next H_i(x) and H_{i+1}(x) for current x i.e. i = 4
        push.0.0.0.0
        loc_loadw.2825
        #=> [H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        # load next H_i(z) and H_{i+1}(z)
        push.0.0.0.0
        loc_loadw.2336
        #=> [H_{i+1}(z)_1, H_{i+1}(z)_0, H_{i}(z)_1, H_{i}(z)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0,
        #    accH_1, accH_0, p2, p1, Acc,      Z ]

        # Compute H_i(x) - H_i(z) and H_{i+1}(x) - H_{i+1}(z)
        movup.5
        movup.5
        swapw
        #=> [H_{i}(z)_1, H_{i}(z)_0, H_{i}(x)_1, H_{i}(x)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, 
        #   accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2sub
        #=> [H_{i}_1, H_{i}_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i}_0, H_{i}_1) = (H_{i}(x)_0 - H_{i}(z)_0, H_{i}(x)_1 - H_{i}(z)_1)

        movdn.5
        movdn.5
        ext2sub
        neg
        swap
        neg
        swap
        #=> [H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i+1}_0, H_{i+1}_1) = (H_{i+1}(x)_0 - H_{i+1}(z)_0, H_{i+1}(x)_1 - H_{i+1}(z)_1)

        # Load the random coefficients and compute the two products for i and i+1
        swapw
        push.0.0.0.0
        dup.7
        add.1
        swap.8
        mem_loadw
        #=> [delta_{i+1}_1, delta_{i+1}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, 
        #   H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, Acc,      Z ]

        movupw.2
        movup.5
        movup.5
        #=> [delta_{i+1}_1, delta_{i+1}_0, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, 
        #   accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        #=> [prod_{i+1}_0, prod_{i+1}_1, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i+1}_0, prod_{i+1}_1) = (H_{i+1}_0, H_{i+1}_1) * delta_{i+1}

        movdn.5
        movdn.5
        #=> [H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, prod_{i+1}_1, prod_{i+1}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        movdn.3
        movdn.3
        #=> [prod_{i+1}_1, prod_{i+1}_0, prod_i_1, prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i}_0, prod_{i}_1) = (H_{i}_0, H_{i}_1) * delta_{i}

        ext2add
        #=> [prod_{i+1}_1 + prod_i_1, prod_{i+1}_0 + prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        ext2add
        #=> [accH_1, accH_0, p2, p1, Acc,      Z ]

        # load next H_i(x) and H_{i+1}(x) for current x i.e. i = 6
        push.0.0.0.0
        loc_loadw.2826
        #=> [H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        # load next H_i(z) and H_{i+1}(z)
        push.0.0.0.0
        loc_loadw.2337
        #=> [H_{i+1}(z)_1, H_{i+1}(z)_0, H_{i}(z)_1, H_{i}(z)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i}(x)_1, H_{i}(x)_0,
        #    accH_1, accH_0, p2, p1, Acc,      Z ]

        # Compute H_i(x) - H_i(z) and H_{i+1}(x) - H_{i+1}(z)
        movup.5
        movup.5
        swapw
        #=> [H_{i}(z)_1, H_{i}(z)_0, H_{i}(x)_1, H_{i}(x)_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, 
        #   accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2sub
        #=> [H_{i}_1, H_{i}_0, H_{i+1}(x)_1, H_{i+1}(x)_0, H_{i+1}(z)_1, H_{i+1}(z)_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i}_0, H_{i}_1) = (H_{i}(x)_0 - H_{i}(z)_0, H_{i}(x)_1 - H_{i}(z)_1)

        movdn.5
        movdn.5
        ext2sub
        neg
        swap
        neg
        swap
        #=> [H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (H_{i+1}_0, H_{i+1}_1) = (H_{i+1}(x)_0 - H_{i+1}(z)_0, H_{i+1}(x)_1 - H_{i+1}(z)_1)

        # Load the random coefficients and compute the two products for i and i+1
        swapw
        push.0.0.0.0
        dup.7
        add.1
        swap.8
        mem_loadw
        #=> [delta_{i+1}_1, delta_{i+1}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, Acc,      Z ]

        movupw.2
        movup.5
        movup.5
        #=> [delta_{i+1}_1, delta_{i+1}_0, H_{i+1}_1, H_{i+1}_0, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        #=> [prod_{i+1}_0, prod_{i+1}_1, H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i+1}_0, prod_{i+1}_1) = (H_{i+1}_0, H_{i+1}_1) * delta_{i+1}

        movdn.5
        movdn.5
        #=> [H_{i}_1, H_{i}_0, delta_{i}_1, delta_{i}_0, prod_{i+1}_1, prod_{i+1}_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        ext2mul
        movdn.3
        movdn.3
        #=> [prod_{i+1}_1, prod_{i+1}_0, prod_i_1, prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]
        # where (prod_{i}_0, prod_{i}_1) = (H_{i}_0, H_{i}_1) * delta_{i}

        ext2add
        #=> [prod_{i+1}_1 + prod_i_1, prod_{i+1}_0 + prod_i_0, accH_1, accH_0, p2, p1, Acc,      Z ]

        ext2add
        #=> [accH_1, accH_0, p2, p1, Acc, Z, y, ptr_query ]
        #=> [accH_1, accH_0, p2, p1, acc_z_1, acc_z_0, acc_gz_1, acc_gz_0,      Z ]

        # Divide by (x - z), (x - gz)
        swapw.2
        swapw
        #=> [acc_z_1, acc_z_0, acc_gz_1, acc_gz_0, (x - z)_1, (x - z)_0, (x - gz)_1, (x - gz)_0, accH_1, accH_0, p2, p1, y, ptr_query ]

        movup.5
        movup.5
        ext2div
        #=> [query_z_1, query_z_0, acc_gz_1, acc_gz_0, (x - gz)_1, (x - gz)_0, accH_1, accH_0, p2, p1, y, ptr_query ]
        # where (query_z_0, query_z_1) = (acc_z_0, acc_z_1)/(x - z)

        movdn.5
        movdn.5
        #=> [acc_gz_1, acc_gz_0, (x - gz)_1, (x - gz)_0, query_z_1, query_z_0, accH_1, accH_0, p2, p1, y, ptr_query ]

        movup.3
        movup.3
        ext2div
        #=> [query_gz_1, query_gz_0, query_z_1, query_z_0, accH_1, accH_0, p2, p1, y, ptr_query ]

        # Sum the two accumulators to get the part of the query comming from the traces
        ext2add
        #=> [query_trace_1, query_trace_0, accH_1, accH_0, p2, p1, y, ptr_query ]

        # Divide the constraint composition polynomial accumulator by (x - z^8)
        ## Get x 
        push.0.0.0.0
        loc_loadw.11
        movdn.3
        push.0
        loc_loadw.2251
        #=> [z^8_1, z^8_0, z1, z0, x, query_trace_1, query_trace_0, accH_1, accH_0, p2, p1, y, ptr_query ]

        ## Compute the denominator
        neg
        swap
        movup.4
        swap
        sub
        swap
        #=> [-z^8_1, x - z^8_0, z1, z0, query_trace_1, query_trace_0, accH_1, accH_0, p2, p1, y, ptr_query ]

        ## Divide by the computed denominator
        movdn.5
        movdn.5
        swapw
        #=> [-z^8_1, x - z^8_0, accH_1, accH_0, z1, z0, query_trace_1, query_trace_0, p2, p1, y, ptr_query  ]
        ext2div
        #=> [query_constr_1, query_constr_0, z1, z0, query_trace_1, query_trace_0, p2, p1, y, ptr_query  ]

        # Sum the two parts to get the deep evaluation query value for current x (without degree adjustment)
        movup.5
        movup.5
        ext2add
        #=> [eval_tmp_1, eval_tmp_0, y, y, p2, p1, y, ptr_query ]

        # Multiply the evaluation by the degree adj factor (alpha + x * beta)
        ## Load the next two random coefficients
        movup.3
        movup.3
        push.00
        movdn.5
        #=> [y, y, eval_tmp_1, eval_tmp_0, p2, 00, p1, y, ptr_query ]
        swapw
        swap.2
        #=> [p1, 00, p2, y, y, y, eval_tmp_1, eval_tmp_0, ptr_query ]
        mem_loadw
        #=> [alpha1, alpha0, beta1, beta0, y, eval_tmp_1, eval_tmp_0, ptr_query, ]

        ## Load x
        push.0.0.0.0
        loc_loadw.11
        #=> [x, y, y, y, alpha1, alpha0, beta1, beta0, y, eval_tmp_1, eval_tmp_0, ptr_query, ]

        ## Compute (alpha * x + beta)
        swapw
        swap
        dup.4
        #=> [x, alpha0, alpha1, beta1, beta0, x, y, y, y, y, eval_tmp_1, eval_tmp_0, ptr_query, ]
        mul
        movup.3
        add
        #=> [beta0 + x* alpha0, alpha1, beta1, x, y, y, y, y, eval_tmp_1, eval_tmp_0, ptr_query, ]
        movdn.3
        movup.2
        mul
        add
        #=> [x * alpha1 + beta1, beta0 + x * alpha0, y, y, y, y, eval_tmp_1, eval_tmp_0, ptr_query, ]
        
        # Compute deep evaluation for the current x
        movup.7
        movup.7
        #=> [eval_tmp_1, eval_tmp_0, alpha1 + beta1, beta0 + x* alpha0, y, y, y, y, ptr_query, ]
        ext2mul
        #=> [eval_1, eval_0, y, y, y, y, ptr_query, ]

        # Store [poe, index, eval_1, eval_0] 
        # where poe := g^index = x / offset.
        movdn.5
        movdn.5
        dup.6
        #=> [ptr_query, y, y, y, y, eval_1, eval_0, ptr_query, ]
        mem_loadw
        #=> [index, depth, y, y, eval_1, eval_0, ptr_query, ]
        movdn.3
        push.0
        loc_loadw.11
        div.7
        #=> [poe, y, y, y, index, eval_1, eval_0, ptr_query, ]
        movdn.3
        drop drop drop
        #=> [poe, index, eval_1, eval_0, ptr_query, ]

        dup.4
        add.1
        swap.5
        mem_storew
        #=> [depth, index, eval_1, eval_0, ptr_query_n]

        # Prepare stack for next iteration
        # TODO: simplify/optimize this
        dup.4
        #=> [ptr_query_n, depth, index, eval_1, eval_0, ptr_query_n]
        push.0.0.0
        #=> [0, 0, 0, ptr_query_n, depth, index, eval_1, eval_0, ptr_query_n]

        repeat.3
            push.0.0.0.0
        end
        #=> [Y, Y, Y, 0, 0, 0, ptr_query_n, Y, ptr_query_n]

        swapw.3
        #=> [0, 0, 0, ptr_query_n, Y, Y, Y, Y, ptr_query_n]

        dup.3
        #=> [ptr_query_n, Y, Y, Y, Y, Y, ptr_query_n]
    end

    repeat.4 dropw end
    drop drop

    # Call the FRI verifier
    ## Get domain generator and a pointer to the remainder codeword
    loc_loadw.9
    push.0.0
    loc_loadw.8
    swap.3
    drop drop drop
    #=>[ptr_remainder, g]

    ## Get the pointer to the first layer commitment
    locaddr.2500

    ## Get the pointer to the first FRI query
    locaddr.2473
    #=> [ptr_query, ptr_layer, ptr_remainder, domain_gen]

    ## Call FRI verifier
    exec.frie2f4::verify
    #=> ()
end